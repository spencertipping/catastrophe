# Catastrophe tracing debugger | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# Catastrophe allows you to trace a function's execution and later query the log to identify certain conditions. To do this, it implements two mostly-independent pieces. The first is a
# caterwaul-powered trace annotator that creates a global tracing hook and transforms functions to invoke this hook before and after each Javascript native instruction, and the second is an
# object that represents a collection of instruction events.

# Note that catastrophe contains its own copy of caterwaul; it hides its copy to prevent interference with the one in the surrounding context.

caterwaul.module('catastrophe', ':all', function ($) {

  (catastrophe = tracer_for) /-$.merge/ statics
  -where [global  = $.context,
          statics = capture [caterwaul = $.deglobalize()],

# Trace implementation.
# The tracer is implemented as a syntax tree grammar. However, rather than being used as a modifier (e.g. the -seq macro), this grammar is used to transform unannotated contents. That is, it
# requires no annotation within the source to activate substitution. Fortunately, the caterwaul grammar module can easily handle this use case.

  # Configuration.
#   Tracers are configured when you create them. You do this by passing a hash of options to catastrophe(). For example:

  # | var tracer = catastrophe({pre_trace: false})

    # Mocking.
#     You can use the tracer to replace certain subexpressions with mocks that you control. To do this, you specify an object that maps syntax tree patterns to replacements that contain your
#     mocking implementations. You'll want to understand how to build caterwaul syntax trees in order to use this feature productively, but here's a small example:

    # | var log_and_eval = function (x) {console.log(x); return eval(x)},
#           tracer       = catastrophe({mocks: {'eval(_x)': 'log_and_eval(_x)'}});
#       tracer(function () {
#         eval(5);
#       })();

    # You don't have to use global functions; you can close over local values by using refs:

    # | tracer = catastrophe({mocks: {'eval(_x)': 'log_and_eval(_x)'.qs.replace({log_and_eval: new $.ref(given.x in console.log(x) -then- eval(x))})}});

    # Note that mocking doesn't turn of tracing by default; if you want to use Catastrophe just to mock things, use 'trace: false' in the options hash.

    # Trace patterns.
#     If you're debugging a large body of code, you often won't want to trace everything. Instead, you'll be interested in particular expressions that follow a given syntactic pattern. To save
#     time during the transformation step, you can choose to annotate only those subexpressions:

    # | var tracer = catastrophe({patterns: ['foo(_x)', '_y + bar']});
#       tracer(function () {
#         if (foo(6)) {                                   // this is traced
#           return y + bif;                               // not traced
#         } else {
#           return 'hi there'.toUpperCase() + bar;        // traced
#         }
#       })();

    # Compilation environment.
#     Any function you trace will lose its closure bindings. Normally this isn't a problem because you'd generally want to trace global functions. But you can reconstruct any bindings that are
#     important by using the 'environment' option:

    # | var tracer = catastrophe({environment: {x: 10}});
#       tracer(function () {return x})()   -> 10

    # You can bind arbitrarily complex values this way. You can also use this mechanism to mock the behavior of global values.

    # Eval wrapping.
#     In the admittedly strange world I live in, it isn't strange for code to eval() other code into existence. Sometimes the evaled code contains functions of its own, and those functions
#     should be traced accordingly. As a result, the default mocking table includes mocked versions of eval() and 'new Function()' that annotate the code being compiled before compiling it. If
#     there are other evaluation forms, you'll need to add more hooks for those.

    # Eval tracing can be disabled by setting trace_native_eval_forms to false.

    # Pre-tracing.
#     Catastrophe can't apply closed-world analysis to Javascript programs; at the very least, any given platform could provide arbitrarily many native functions. This means that any expression
#     could conceivably throw an error. In order to pinpoint that error without putting a try/catch around every expression (expensive), catastrophe uses 'pre-tracing'. This is just an indicator
#     that an expression is going to be evaluated but hasn't yet been reached. So, for example, the trace for f(g(x), y) would be:

    # |  1. pre-evaluate f(g(x), y)
#        2. pre-evaluate f
#        3. evaluate f
#        4. pre-evaluate g(x)
#        5. pre-evaluate g
#        6. evaluate g
#        7. pre-evaluate x
#        8. evaluate x
#        9. evaluate g(x)
#       10. pre-evaluate y
#       11. evaluate y
#       12. evaluate f(g(x), y)

    # Any error would leave pre-evaluate steps without corresponding evaluate steps. These steps contain the backtrace for the error. If you don't want this functionality, use 'pre_trace: false'
#     in the options hash. (Disabling pre-tracing will make the debugging code run faster.)

          tracer_for(options) = trace -where [default_options = {mocks: {},  allow_mock_annotations: true,        trace_native_eval_forms: true,  environment: {},           pre_trace: true,
                                                            timestamps: true,             hook_name: 'catastrophe_hook' /!$.gensym,  hook: null,       global: global,  trace_log_size: 1 << 20,
                                                              patterns: null,                 trace: true},

                                              settings        = {} / default_options /-$.merge/ options,
                                              self()          = trace.apply(this, arguments),
                                              eval_mocks      = settings.trace_native_eval_forms ? eval_mocks_for(self) : {},
                                              all_mocks       = eval_mocks /-$.merge/ settings.mocks,

                                              trace           = compiler(settings /-$.merge/ {mocks: all_mocks, trace_log: [], error_log: [],
                                                                                           patterns: settings.patterns && settings.patterns *$.parse -seq})

                                                                /-$.merge/ wcapture [options                = settings,

                                                                                     find(pattern)          = collection(trace_log %[t /~match/ x.tree] -seq, t) -where [t = $.parse(pattern)],
                                                                                     errors()               = error_log *[collection(x, '_x')] -seq,

                                                                                     trace_log              = options.trace_log,
                                                                                     error_log              = options.error_log,
                                                                                     hook                   = options.hook -oeq- hook_for(options),
                                                                                     install_hook()         = options.global && (options.global[options.hook_name] = hook),
                                                                                     remove_hook()          = options.global && delete options.global[options.hook_name]]

                                                                -se- it.install_hook()],

  # Querying support.
#   Querying is designed to be easy to use from a non-caterwaul console. As such, collections returned from queries have a bunch of iteration methods that you can use to quickly select what
#   you're looking for. These methods will eval() strings into functions so that you don't have to type as much boilerplate.

          collection(x, pattern) = x /-$.merge/ collection_methods -se [it.match_context = pattern],
          collection_methods     = wcapture [function_compiler = $(':all'),
                                             promote(f)        = f.constructor === Function ? f : this.compile_string(f),
                                             compile_string(s) = 'given.x [#{s}, where [match = match_context /~match/ x.tree]]' /-function_compiler/ {match_context: this.match_context},

                                             map(s)            = collection(this *f -seq, this.match_context) -where [f = this.promote(s)],
                                             filter(s)         = collection(this %f -seq, this.match_context) -where [f = this.promote(s)]],

  # Trace grammar implementation.
#   Javascript is fairly straightforward to implement. The only thing we need to do is track expression roles and make sure that our instrumentation code doesn't change them. For example, we
#   can't instrument every identifier occurrence by wrapping it with an invocation like 'trace(x)', since 'var x = 10' would become invalid. In this case, 'x' is an lvalue, and it needs to stay
#   this way across the trace annotation.

  # The tracer uses several different markers to track state:

  # | S  statement; this is something that appears in front of a ;
#     R  rvalue (generic expression without any restrictions)
#     L  lvalue (expression that cannot be traced)
#     U  code which should be unreachable
#     C  terminal closure scope hook (allows get/set of lexical closure variables)
#     H  terminal expression hook

  # The terminal markers don't generate any others; they are rewritten into the final hook forms.

          grammar(options) = $.grammar('L U R C H S'.qw, {initial: 'S[_x]'.qs}, cc) -where [cc(rule, anon) = tracing_rules() + custom_rules() -seq

          -where [tracing_rules() = options.trace ? unreachables + statements + lvalues + rvalues + hooks + closures -seq : ['S[_x]'.qs /-rule/ '_x'.qs],
                  custom_rules()  = options.mocks /pairs *[x[0] /!$.parse /!anon /-rule/ process_mock(x[1] /!process_mock)] -seq
                            -where [annotate           = options.allow_mock_annotations ? anon : "_".qf,
                                    process_mock(tree) = tree instanceof Function ? tree : tree /!$.parse /!annotate],

    # Unreachable hooks.
#     These don't appear in the final output right now. They just exist so that I can keep track of stuff that theoretically can't be reached.

                  unreachables = ['U[_x]'.qs /-rule/ ''.qs],

    # Statement-level hooks.
#     Statements themselves aren't traced, but it's necessary to walk through them to get to expression-level stuff and to contextualize lvalues correctly. The base case for statements falls
#     through to rvalue expressions; this reflects the fact that you can have an expression whose return value is not used.

                  statements = ['S[_x]'.qs     /-rule/ 'R[_x]'.qs,
                                'S[{_x}]'.qs   /-rule/ '{S[_x]}'.qs,
                                'S[_x _y]'.qs  /-rule/ 'S[_x] S[_y]'.qs,                                                                        // implied semicolon
                                'S[_x; _y]'.qs /-rule/ 'S[_x]; S[_y]'.qs,

                                'S[var _vs, _name = _value]'.qs          /-rule/ 'S[var _vs]; S[var _name = _value]'.qs,
                                'S[var _vs, _name@0]'.qs                 /-rule/ 'S[var _vs]; S[var _name]'.qs,
                                'S[var _name = _value]'.qs               /-rule/ 'var L[_name] = R[_value]'.qs,
                                'S[var _name@0]'.qs                      /-rule/ 'var L[_name]'.qs,

                                'S[for (_x; _y; _z) _body]'.qs           /-rule/ 'for (S[_x]; R[_y]; R[_z]) S[_body]'.qs,
                                'S[for (var _name in _o) _body]'.qs      /-rule/ 'for (var L[_name] in R[_o]) S[_body]'.qs,
                                'S[for (var _name in _1, _2) _body]'.qs  /-rule/ 'for (var L[_name] in R[_1], R[_2]) _body'.qs,                 // TODO: fully generalize
                                'S[for (var _name in _1 = _2) _body]'.qs /-rule/ 'for (var L[_name] in L[_1] = R[_2]) _body'.qs,                // TODO: fully generalize
                                'S[do _body while (_cond)]'.qs           /-rule/ 'do S[_body] while (R[_cond])'.qs,
                                'S[while (_cond) _body]'.qs              /-rule/ 'while (R[_cond]) S[_body]'.qs,
                                'S[with (_x) _body]'.qs                  /-rule/ 'with (R[_x]) S[_body]'.qs,

                                'S[if (_cond) _body]'.qs                 /-rule/ 'if (R[_cond]) S[_body]'.qs,
                                'S[if (_cond) _body else _else]'.qs      /-rule/ 'if (R[_cond]) S[_body] else S[_else]'.qs,

                                'S[try _x catch _y finally _z]'.qs       /-rule/ 'try S[_x] catch S[_y] finally S[_z]'.qs,
                                'S[try _x catch _y]'.qs                  /-rule/ 'try S[_x] catch S[_y]'.qs,
                                'S[try _x finally _y]'.qs                /-rule/ 'try S[_x] finally S[_y]'.qs,
                                'S[throw _x]'.qs                         /-rule/ 'throw R[_x]'.qs,
                                'S[return _x]'.qs                        /-rule/ 'return R[_x]'.qs,

                                'S[throw _x; _y]'.qs                     /-rule/ 'S[throw _x]; U[_y]'.qs,
                                'S[return _x; _y]'.qs                    /-rule/ 'S[return _x]; U[_y]'.qs,

                                'S[switch (_value) {_cases}]'.qs         /-rule/ 'switch (R[_value]) {S[_cases]}'.qs,
                                'S[_x: _y]'.qs                           /-rule/ '_x: S[_y]'.qs],               // covers both 'case x:' and labels within blocks (: left-associates)

    # Lvalue cases.
#     In some of these cases we can transform pieces of the lvalue but leave the lvalue itself intact. For example, 'foo.bar[bif]' contains 'foo.bar' as an rvalue, so we are free to transform
#     this expression arbitrarily.

                  lvalues = ['L[_x@0]'.qs   /-rule/ '_x'.qs,        'L[_x[_y]]'.qs /-rule/ 'R[_x][L[_y]]'.qs,
                             'L[_x._y]'.qs  /-rule/ 'R[_x]._y'.qs,  'L[_x(_y)]'.qs /-rule/ 'U[_x(_y)]'.qs],     // case for legacy IE code; this should be unreachable

    # Rvalue cases.
#     These are generally easy cases that lead to terminal hook rules. Some operators take lvalues (delete, for instance), so this is modeled accordingly. There are a few odd cases here, most
#     notably typeof. typeof can be used in two different ways: one way gives you the primitive type of a value, and the other way checks for the existence of a global variable. We need to
#     handle the second case conservatively, since triggering any evaluation of a nonexistent global would introduce an error into the instrumented code.

    # Note that certain properties have been intentionally preserved. For instance, the comma operator's result is not traced because doing so prevents the comma from being used as an argument
#     or array entry separator.

                  rvalues = ['R[_x@0]'.qs      /-rule/ 'H[_x]'.qs,               'R[]'.qs            /-rule/ ''.qs,
                             'R[delete _x]'.qs /-rule/ 'H[delete L[_x]]'.qs,     'R[new _f(_xs)]'.qs /-rule/ 'new _f(R[_xs])'.qs,               // TODO: trace this with better granularity
                             'R[_x._y]'.qs     /-rule/ 'H[R[_x].y]'.qs,          'R[(_x)]'.qs        /-rule/ '(R[_x])'.qs,
                             'R[_x[_y]]'.qs    /-rule/ 'H[R[_x][R[_y]]]'.qs,     'R[[_x]]'.qs        /-rule/ 'H[[R[_x]]]'.qs,
                             'R[_x, _y]'.qs    /-rule/ 'R[_x], R[_y]'.qs,        'R[{_x}]'.qs        /-rule/ 'H[{R[_x]}]'.qs,

                             'R[_x(_y)]'.qs    /-rule/ 'H[R[_x](R[_y])]'.qs,
                             'R[_x._y(_z)]'.qs /-rule/ 'H[R[_x]._y(R[_z])]'.qs,  'R[_x[_y](_z)]'.qs  /-rule/ 'H[R[_x][R[_y]](R[_z])]'.qs,

                             'R[void _x]'.qs   /-rule/ 'void R[_x]'.qs,          'R[typeof _x]'.qs   /-rule/ 'H[typeof R[_x]]'.qs,
                             'R[_x: _y]'.qs    /-rule/ '_x: R[_y]'.qs,           'R[typeof _x@0]'.qs /-rule/ 'H[typeof _x]'.qs,

                             'R[+_x]'.qs       /-rule/ 'H[+R[_x]]'.qs,           'R[~_x]'.qs         /-rule/ 'H[~R[_x]]'.qs,
                             'R[-_x]'.qs       /-rule/ 'H[-R[_x]]'.qs,           'R[!_x]'.qs         /-rule/ 'H[!R[_x]]'.qs,
                             'R[++_x]'.qs      /-rule/ 'H[++L[_x]]'.qs,          'R[_x++]'.qs        /-rule/ 'H[L[_x]++]'.qs,
                             'R[--_x]'.qs      /-rule/ 'H[--L[_x]]'.qs,          'R[_x--]'.qs        /-rule/ 'H[L[_x]--]'.qs] +

                            (binary + assign) *[x[0] /-rule/ x[1]] +

                            ['R[_x ? _y : _z]'.qs              /-rule/ 'H[R[_x] ? R[_y] : R[_z]]'.qs,

                             'R[function () {_body}]'.qs       /-rule/ 'function () {C; S[_body]}'.qs,        'R[function () {}]'.qs       /-rule/ 'function () {C}'.qs,
                             'R[function (_xs) {_body}]'.qs    /-rule/ 'function (_xs) {C; S[_body]}'.qs,     'R[function (_xs) {}]'.qs    /-rule/ 'function (_xs) {C}'.qs,
                             'R[function _f () {_body}]'.qs    /-rule/ 'function _f () {C; S[_body]}'.qs,     'R[function _f () {}]'.qs    /-rule/ 'function _f () {C}'.qs,
                             'R[function _f (_xs) {_body}]'.qs /-rule/ 'function _f (_xs) {C; S[_body]}'.qs,  'R[function _f (_xs) {}]'.qs /-rule/ 'function _f (_xs) {C}'.qs] -seq

        -where [binary = '+ - * / % << >> >>> < > <= >= instanceof in == != === !== & ^ | && ||'.qw *[[caterwaul.parse('R[_x #{x} _y]'), caterwaul.parse('H[R[_x] #{x} R[_y]]')]] -seq -ahead,
                assign = '= += -= *= /= %= <<= >>= >>>= &= |= ^='.qw                                *[[caterwaul.parse('R[_x #{x} _y]'), caterwaul.parse('H[L[_x] #{x} R[_y]]')]] -seq -ahead],

    # Hook rules.
#     There are two kinds of hooks that we use to instrument the code. The simple case is hooking an expression; this is triggered by using the H[] annotation in the rule table, or by generating
#     H[] nodes from a mocking table entry (this only works if allow_mock_annotations is set to true). The other case is hooking a closure scope, which is a bit more involved.

      # Expression hooks.
#       This is straightforward. We basically just generate a call to the globally-installed hook function (or the closure function if hook_name is set to null). We also generate a pre-call
#       unless pre_trace is set to false.

      # The only particularly interesting thing that happens here is maintaining the backtrace stack. When pre-tracing is enabled, we push an entry for each expression that will be evaluated and
#       pop an entry for expressions that completed successfully. However, naive popping won't do the right thing. The reason is that an error will cause a nonlocal jump that will disrupt the
#       normal execution flow. Naive popping from the new point would cause the error backtrace (which is valuable) to be stuck in the middle of the regular backtrace and probably eventually
#       destroyed.

      # To fix this, we go through the stack, starting with the most recent entry, to look for a matching node, and stash those entries in a separate error backtrace log. We then nuke all of
#       those entries from the main stack since they are no longer meaningful. Doing all of this imposes a nontrivial amount of overhead, which is one reason you might want to disable
#       pre-tracing.

      # Here is the information provided to the hook function:

      # | pre-trace: hook(syntax-node)
#         trace:     hook(syntax-node, value) -> value

      # It is important that the hook function return the value it is tracing. Otherwise the program's semantics will be changed! If no value is given to the hook function, its return value will
#       be unused.

                  hook_ref                  = new $.syntax(options.hook_name),
                  pre_hook_form             = '(h(_x), h(_x, (_value)))'.qs /~replace/ {h: hook_ref},
                  hook_form                 = 'h(_x, (_value))'.qs          /~replace/ {h: hook_ref},

                  remove_markers_memo       = {},
                  remove_markers_from(tree) = remove_markers_memo[tree.id()] -oeq- tree.rmap(n.data === '[]' && $.is_gensym(n[0].data) ? remove_markers_from(n[1]) : false, given.n),
                  hook(t)                   = t.is_constant() || (options.patterns && options.patterns |![x /~match/ remove_markers_from(t)] |seq) ? t :
                                                (options.pre_trace ? pre_hook_form : hook_form) /~replace/ {_x: new $.ref(remove_markers_from(t)), _value: t},

                  hooks                     = ['H[_x]'.qs /-rule/ "hook(_._x)".qf],

      # Closure hooks.
#       This is cool. The idea is to be able to inspect and modify the closure state of any function. This isn't very difficult, it turns out; we just need to insert some header code that is
#       able to do this for us. We also need to know which variables are closed by the function, but this is not particularly challenging either.

      # The header code's job is to intercept certain calls and either get or set the closure state. These calls cannot ever be generated by the original program; otherwise the semantics will be
#       changed. The protocol I'm using for this is calling the function with 'this' set to the hook function. If we're getting the state, there will be no arguments; if we're setting it, the
#       first argument will be an object containing state changes. Here's roughly what this logic looks like:

      # | if (this === hook) if (arguments.length) 'var1' in arguments[0] && (var1 = arguments[0].var1),
#                                                  'var2' in arguments[0] && (var2 = arguments[0].var2), ...;
#                            else                  return {closure_object};

      # The function's closure scope is simply its set of identifiers minus the ones that are local to it. Each of these sets is stored as an object on the 'function' node.

                  closures = ['C'.qs /-rule/ 'null'.qs]]],                                                                                      // TODO: implement this

  # Hook function.
#   Catastrophe's default hook function does several things that may be useful:

  # | 1. Builds up a backtrace for each error that occurs, provided that pre-tracing is enabled
#     2. Records a timestamp for each pre-trace and trace entry (this can be disabled by using timestamps: false)
#     3. Prevents unbounded trace log growth by purging old entries (adjustable using trace_log_size)

  # Normally the hook is bound as a global variable, but you can disable this by setting 'global' to null.

          hook_for(options) = observe -where [observe(t, v)     = arguments.length === 2 ? resolve(t, v) : enqueue(t),
                                              enqueue(t)        = bt /~push/ {tree: t, time: options.timestamp && +new Date()},
                                              resolve(t, v)     = trace_log /~push/ {tree: t, value: v, time: options.timestamp && +new Date(), pre_trace: options.pre_trace && dequeue(t)}
                                                                  -then- trim_trace_log() /when [trace_log.length > options.trace_log_size << 1]
                                                                  -then- v,

                                              dequeue(t)        = bt.length && bt[bt.length - 1].tree === t ? bt.pop() : dequeue_remote(t),

                                              // Look through the backtrace for the tree. This is O(n) in the backtrace size, which makes error recovery quite expensive. At some point in the
                                              // future I'll probably fix this by folding the backtrace into a set of known keys and quickly rejecting failed searches. This would reduce the
                                              // impact to just one O(n) lookup.
                                              dequeue_remote(t) = error_log /~push/ error_trace -then- entry -where [index       = bt |~![x.tree === t][xi] |seq,
                                                                                                                     entry       = bt[index],
                                                                                                                     error_trace = bt.splice(index, bt.length - index)],

                                              trim_trace_log()  = trace_log.splice(trace_log.length - options.trace_log_size, options.trace_log_size),
                                              bt                = options.pre_trace && [],
                                              trace_log         = options.trace_log,
                                              error_log         = options.pre_trace && options.error_log -oeq- []],

  # Eval tracing.
#   Catastrophe traces calls to eval() and new Function() by default. These are known sites where code is generated at runtime, and catastrophe instruments that code before it is compiled. You
#   can mock out other evaluation primitives as well. This is fairly simple to do; you just use the tracer on the code. For example:

  # | {mocks: {'some_eval_form(_code)': 'some_eval_form(my_tracer(_code))'.qs /~replace/ {my_tracer: tracer}}}

  # Note that eval tracing doesn't catch everything, but it does catch the most common cases. In particular, it fails when you alias the eval() function or the Function constructor and invoke it
#   via that alias. So, for example, this code will generate an untraced function:

  # | var f = Function;
#     var g = new f('return x + y', 'x', 'y');
#     // g is untraced

  # Theoretically, this gap could be closed by alias-checking each constructor invocation and function call. However, I'm not really up for implementing that at the moment, and aliasing these
#   things is so uncommon that I doubt it's an issue.

          eval_tracer_for(self) = "self(_ /!$.parse).toString()".qf,
          eval_mocks_for(self)  = {'R[eval(_x)]':          'eval(trace(R[_x]))'.qs /~replace/ {trace: new $.ref(eval_tracer_for(self))},
                                   'R[new Function(_xs)]':  patch_first_argument -where [frame       = 'new Function(R[_xs])'.qs,
                                                                                         trace_frame = 'trace(_x)'.qs /~replace/ {trace: new $.ref(eval_tracer_for(self))},
                                                                                         trace(xs)   = xs.flatten(',').map(i ? x : trace_frame.replace({_x: x}), given [x, i]).unflatten(),

                                                                                         patch_first_argument(match) = frame /~replace/ {_xs: match._xs /!trace}]},

  # Trace compiler.
#   This is actually quite straightforward. All of the work has already been done in the grammar; we just need to invoke the caterwaul compiler on the traced tree and the environment. We can
#   assume that the global hook has already been installed.

          compiler(options) = trace_and_compile -where [trace                             = grammar(options),
                                                        wrapped_trace                     = $("trace({_x: _})".qf),
                                                        trace_and_compile(f, environment) = wrapped_trace(f, {} / options.environment /-$.merge/ environment,
                                                                                                             {transparent_errors: false, gensym_renaming: false})]]});

# Generated by SDoc 
